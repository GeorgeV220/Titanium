From 6d4720f8a574f07090fe7cb97aa6c4f49fca78a3 Mon Sep 17 00:00:00 2001
From: Aikar <aikar@aikar.co>
Date: Sun, 19 Apr 2020 04:28:29 -0400
Subject: [PATCH] Implement [Paper-0451] Load Chunks for Login Asynchronously
 by Aikar


diff --git a/src/main/java/net/minecraft/server/ChunkCoordIntPair.java b/src/main/java/net/minecraft/server/ChunkCoordIntPair.java
index 652c07975..8bee6acc7 100644
--- a/src/main/java/net/minecraft/server/ChunkCoordIntPair.java
+++ b/src/main/java/net/minecraft/server/ChunkCoordIntPair.java
@@ -65,6 +65,8 @@ public class ChunkCoordIntPair {
         return new BlockPosition(this.a(), i, this.b());
     }
 
+    public BlockPosition asPosition() { return a(0); } // Paper - OBFHELPER
+
     public String toString() {
         return "[" + this.x + ", " + this.z + "]";
     }
diff --git a/src/main/java/net/minecraft/server/ChunkProviderServer.java b/src/main/java/net/minecraft/server/ChunkProviderServer.java
index 593017bb9..3984c2c60 100644
--- a/src/main/java/net/minecraft/server/ChunkProviderServer.java
+++ b/src/main/java/net/minecraft/server/ChunkProviderServer.java
@@ -120,6 +120,12 @@ public class ChunkProviderServer implements IChunkProvider {
         // do nothing, override in async
     }
 
+    public void bumpAreaPriority(ChunkCoordIntPair coords, int radius) {
+        for (ChunkCoordIntPair c : this.getSpiralOutChunks(coords.asPosition(), radius)) {
+            this.bumpPriority(c);
+        }
+    }
+
     public List<ChunkCoordIntPair> getSpiralOutChunks(BlockPosition blockposition, int radius) {
         List<ChunkCoordIntPair> list = new ArrayList<>();
 
diff --git a/src/main/java/net/minecraft/server/EntityPlayer.java b/src/main/java/net/minecraft/server/EntityPlayer.java
index 2285cdcf2..0c9bc3199 100644
--- a/src/main/java/net/minecraft/server/EntityPlayer.java
+++ b/src/main/java/net/minecraft/server/EntityPlayer.java
@@ -31,6 +31,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public String locale = "en_US"; // Spigot
     public long lastSave = MinecraftServer.currentTick; // Paper
     public PlayerConnection playerConnection;
+    public NetworkManager networkManager; // Paper
     public final MinecraftServer server;
     public final PlayerInteractManager playerInteractManager;
     public double d;
@@ -67,6 +68,7 @@ public class EntityPlayer extends EntityHuman implements ICrafting {
     public boolean keepLevel = false;
     public double maxHealthCache;
     public boolean joining = true;
+    public boolean didPlayerJoinEvent = false; // Paper
     // CraftBukkit end
     // Spigot start
     public boolean collidesWithEntities = true;
diff --git a/src/main/java/net/minecraft/server/LoginListener.java b/src/main/java/net/minecraft/server/LoginListener.java
index 0e5f1ea39..06ed38e41 100644
--- a/src/main/java/net/minecraft/server/LoginListener.java
+++ b/src/main/java/net/minecraft/server/LoginListener.java
@@ -59,7 +59,7 @@ public class LoginListener implements PacketLoginInListener, IUpdatePlayerListBo
         if (this.g == LoginListener.EnumProtocolState.READY_TO_ACCEPT) {
             this.b();
         } else if (this.g == LoginListener.EnumProtocolState.e) {
-            EntityPlayer entityplayer = this.server.getPlayerList().a(this.i.getId());
+            EntityPlayer entityplayer = this.server.getPlayerList().getActivePlayer(this.i.getId()); // Paper
 
             if (entityplayer == null) {
                 this.g = LoginListener.EnumProtocolState.READY_TO_ACCEPT;
@@ -141,7 +141,7 @@ public class LoginListener implements PacketLoginInListener, IUpdatePlayerListBo
             }
 
             this.networkManager.handle(new PacketLoginOutSuccess(this.i));
-            EntityPlayer entityplayer = this.server.getPlayerList().a(this.i.getId());
+            EntityPlayer entityplayer = this.server.getPlayerList().getActivePlayer(this.i.getId()); // Paper
 
             if (entityplayer != null) {
                 this.g = LoginListener.EnumProtocolState.e;
diff --git a/src/main/java/net/minecraft/server/NetworkManager.java b/src/main/java/net/minecraft/server/NetworkManager.java
index 268dec691..9cdd56c34 100644
--- a/src/main/java/net/minecraft/server/NetworkManager.java
+++ b/src/main/java/net/minecraft/server/NetworkManager.java
@@ -222,6 +222,14 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     }
     // PandaSpigot end
 
+    // Titanium start - compatibility
+    public void sendPacket(Packet<?> packet) { this.handle(packet); }
+
+    public void sendPacket(Packet<?> packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener) {
+        this.a(packet, genericfuturelistener, null);
+    }
+    // Titanium end
+
     public void handle(Packet packet) {
         // PandaSpigot start
         this.a(packet, null, null);
@@ -231,7 +239,6 @@ public class NetworkManager extends SimpleChannelInboundHandler<Packet> {
     public void a(Packet packet, GenericFutureListener<? extends Future<? super Void>> genericfuturelistener, GenericFutureListener<? extends Future<? super Void>>[] agenericfuturelistener) {
         // Nacho/WindSpigot start - Async combat
         CombatThread hitDetectionThread = Titanium.get().getHitDetectionThread();
-
         if (hitDetectionThread != null && this.g() && packet instanceof PacketPlayInUseEntity && ((PacketPlayInUseEntity)packet).a() == PacketPlayInUseEntity.EnumEntityUseAction.ATTACK) {
             hitDetectionThread.addPacket(packet, this, agenericfuturelistener);
             return;
diff --git a/src/main/java/net/minecraft/server/PlayerConnection.java b/src/main/java/net/minecraft/server/PlayerConnection.java
index a3857e103..5fd898f15 100644
--- a/src/main/java/net/minecraft/server/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/PlayerConnection.java
@@ -76,6 +76,7 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
     private static final Logger c = LogManager.getLogger();
     public final NetworkManager networkManager;
     private final MinecraftServer minecraftServer;
+    public Runnable playerJoinReady; // Paper
     public EntityPlayer player;
     private int e;
     private int f;
@@ -135,6 +136,13 @@ public class PlayerConnection implements PacketListenerPlayIn, IUpdatePlayerList
     public void c() {
         this.h = false;
         ++this.e;
+        // Paper start - login async
+        Runnable playerJoinReady = this.playerJoinReady;
+        if (playerJoinReady != null) {
+            this.playerJoinReady = null;
+            playerJoinReady.run();
+        }
+        // Paper end
         //this.minecraftServer.methodProfiler.a("keepAlive"); // Purpur
         if ((long) this.e - this.k > 40L) {
             this.k = (long) this.e;
diff --git a/src/main/java/net/minecraft/server/PlayerList.java b/src/main/java/net/minecraft/server/PlayerList.java
index a675874c3..8160d9d2d 100644
--- a/src/main/java/net/minecraft/server/PlayerList.java
+++ b/src/main/java/net/minecraft/server/PlayerList.java
@@ -16,7 +16,9 @@ import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.UUID;
+import net.titanium.AsyncPriority;
 import net.titanium.config.message.MessageConfig;
 import net.titanium.config.TitaniumConfig;
 import net.titanium.console.TitaniumConsoleCommandSender;
@@ -56,11 +58,12 @@ public abstract class PlayerList {
     private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer server;
     public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, EntityPlayer> j = new Object2ObjectOpenHashMap<>(); // Titanium - Use fastutil
+    private final Map<UUID, EntityPlayer> j = new Object2ObjectOpenHashMap<>(); Map<UUID, EntityPlayer> getUUIDMap() { return j; } // Titanium - Use fastutil // Paper - OBFHELPER
     private final GameProfileBanList k;
     private final IpBanList l;
     private final OpList operators;
     private final WhiteList whitelist;
+    private final Map<UUID, EntityPlayer> pendingPlayers = new Object2ObjectOpenHashMap<>(); // Paper
     private final Map<UUID, ServerStatisticManager> o;
     public IPlayerFileData playerFileData;
     private boolean hasWhitelist;
@@ -91,6 +94,13 @@ public abstract class PlayerList {
     }
 
     public void a(NetworkManager networkmanager, EntityPlayer entityplayer) {
+        // Paper start
+        EntityPlayer prev = pendingPlayers.put(entityplayer.getUniqueID(), entityplayer);
+        if (prev != null) {
+            disconnectPendingPlayer(prev);
+        }
+        entityplayer.networkManager = networkmanager;
+        // Paper end
         GameProfile gameprofile = entityplayer.getProfile();
         UserCache usercache = this.server.getUserCache();
         GameProfile gameprofile1 = usercache.a(gameprofile.getId());
@@ -102,7 +112,7 @@ public abstract class PlayerList {
         if (nbttagcompound != null && nbttagcompound.hasKey("bukkit")) {
             NBTTagCompound bukkit = nbttagcompound.getCompound("bukkit");
             s = bukkit.hasKeyOfType("lastKnownName", 8) ? bukkit.getString("lastKnownName") : s;
-        }
+        } String lastKnownName = s; // Paper
         // CraftBukkit end
 
         // PaperSpigot start - support PlayerInitialSpawnEvent
@@ -162,6 +172,38 @@ public abstract class PlayerList {
         entityplayer.getStatisticManager().updateStatistics(entityplayer);
         this.sendScoreboard((ScoreboardServer) worldserver.getScoreboard(), entityplayer);
         this.server.aH();
+        // Paper start - async load spawn in chunk
+        int chunkX = loc.getBlockX() >> 4;
+        int chunkZ = loc.getBlockZ() >> 4;
+        ChunkCoordIntPair pos = new ChunkCoordIntPair(chunkX, chunkZ);
+        worldserver.chunkProviderServer.bumpAreaPriority(pos, 3);
+        worldserver.chunkProviderServer.getChunkAt(chunkX, chunkZ, true, true, AsyncPriority.URGENT, chunk -> {
+            playerconnection.playerJoinReady = () -> {
+                this.postChunkLoadJoin(entityplayer, networkmanager, playerconnection, nbttagcompound, Objects.toString(networkmanager.getSocketAddress(), "local"), lastKnownName);
+            };
+        });
+    }
+
+    public EntityPlayer getActivePlayer(UUID uuid) {
+        EntityPlayer player = this.getUUIDMap().get(uuid);
+        return player != null ? player : pendingPlayers.get(uuid);
+    }
+
+    void disconnectPendingPlayer(EntityPlayer entityplayer) {
+        ChatComponentText msg = new ChatComponentText("You logged in from another location");
+        entityplayer.networkManager.sendPacket(new PacketPlayOutKickDisconnect(msg), (future) -> {
+            entityplayer.networkManager.close(msg);
+            entityplayer.networkManager = null;
+        });
+    }
+
+    private void postChunkLoadJoin(EntityPlayer entityplayer, NetworkManager networkmanager, PlayerConnection playerconnection, NBTTagCompound nbttagcompound, String s1, String s) {
+        pendingPlayers.remove(entityplayer.getUniqueID(), entityplayer);
+        if (!networkmanager.isConnected()) {
+            return;
+        }
+        entityplayer.didPlayerJoinEvent = true;
+        // Paper end
         // CraftBukkit start - login message is handled in the event
         // ChatMessage chatmessage;
 
@@ -178,7 +220,7 @@ public abstract class PlayerList {
         // this.sendMessage(chatmessage);
         this.onPlayerJoin(entityplayer, joinMessage);
         // CraftBukkit end
-        worldserver = server.getWorldServer(entityplayer.dimension);  // CraftBukkit - Update in case join event changed it
+        WorldServer worldserver = server.getWorldServer(entityplayer.dimension);  // CraftBukkit - Update in case join event changed it
         playerconnection.a(entityplayer.locX, entityplayer.locY, entityplayer.locZ, entityplayer.yaw, entityplayer.pitch);
         this.b(entityplayer, worldserver);
         if (this.server.getResourcePack().length() > 0) {
@@ -299,6 +341,7 @@ public abstract class PlayerList {
     }
 
     protected void savePlayerFile(EntityPlayer entityplayer) {
+        if (!entityplayer.didPlayerJoinEvent) return; // Paper - If we never fired PJE, we disconnected during login. Data has not changed, and additionally, our saved vehicle is not loaded! If we save now, we will lose our vehicle (CraftBukkit bug)
         entityplayer.lastSave = MinecraftServer.currentTick; // Paper
         this.playerFileData.save(entityplayer);
         ServerStatisticManager serverstatisticmanager = (ServerStatisticManager) this.o.get(entityplayer.getUniqueID());
@@ -372,7 +415,7 @@ public abstract class PlayerList {
         Player bukkitPlayer = cserver.getPlayer(entityplayer);
         PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(bukkitPlayer, "\u00A7e" + entityplayer.getName() + " left the game.");
         // KigPaper end
-        cserver.getPluginManager().callEvent(playerQuitEvent);
+        if (entityplayer.didPlayerJoinEvent) cserver.getPluginManager().callEvent(playerQuitEvent); // Paper - if we disconnected before join ever fired, don't fire quit
         entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
         // CraftBukkit end
         
@@ -395,6 +438,13 @@ public abstract class PlayerList {
             this.j.remove(uuid);
             this.o.remove(uuid);
         }
+        // Paper start
+        entityplayer1 = pendingPlayers.get(uuid);
+        if (entityplayer1 == entityplayer) {
+            pendingPlayers.remove(uuid);
+        }
+        entityplayer.networkManager = null;
+        // Paper end
 
         // CraftBukkit start
         //  this.sendAll(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[] { entityplayer}));
@@ -422,7 +472,7 @@ public abstract class PlayerList {
         }
         // KigPaper end
 
-        return playerQuitEvent.getQuitMessage(); // CraftBukkit
+        return entityplayer.didPlayerJoinEvent ? playerQuitEvent.getQuitMessage() : null; // CraftBukkit // Paper - don't print quit if we never printed join
     }
 
     // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
@@ -439,6 +489,13 @@ public abstract class PlayerList {
                 arraylist.add(entityplayer);
             }
         }
+        // Paper start - check pending players too
+        entityplayer = pendingPlayers.get(uuid);
+        if (entityplayer != null) {
+            this.pendingPlayers.remove(uuid);
+            disconnectPendingPlayer(entityplayer);
+        }
+        // Paper end
 
         Iterator iterator = arraylist.iterator();
 
@@ -1310,6 +1367,7 @@ public abstract class PlayerList {
         return this.players;
     }
 
+    public EntityPlayer getPlayer(UUID uuid) { return this.a(uuid); } // Paper - OBFHELPER
     public EntityPlayer a(UUID uuid) {
         return (EntityPlayer) this.j.get(uuid);
     }
-- 
2.38.1.windows.1

